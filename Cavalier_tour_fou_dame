from random import *
## Classes pièces

#La couleur noir correspond à -1, blanc à 1. La couleur d'une case inocuppée est 0
#La fonction affine -3.5*couleur + 3.5 associe à la couleur d'une pièce le "côté" de la couleur sur l'échiquier (0 ou 7)

class Vide():

    def __init__(self):
         self.couleur = 0
         self.type = "Vide"
         


class Pion():
    def __init__(self,couleur):
        self.couleur = couleur
        self.ligneInitiale = (-3.5*couleur + 3.5)
        self.type = "Pion"
        self.imprudence = False
        
    def possibilitesAbsolues(self,a,b):
        __Cases=[]
        if a in range(1,7):
            #déplacement normal
            if G[a+self.couleur][b].couleur == 0:
                __Cases.append((a+self.couleur,b))

            #déplacement de deux cases du début
            if a == self.ligneInitiale+self.couleur and G[a+self.couleur][b].couleur == 0 and G[a+2*self.couleur][b].couleur == 0:
                __Cases.append((a+2*self.couleur,b))
            

            #déplacement pour manger une pièce adverse
            for k in [1,-1]: 
                if G[a+self.couleur][b+k].couleur == (-1)*self.couleur:
                    __Cases.append((a+self.couleur,b+k))
                    
            #Prise en passant
            if a == self.ligneInitiale + self.couleur*4 :
                if G[a][b+1].type == "Pion" and G[a][b+1].couleur == -self.couleur and G[a][b+1].imprudence and G[a+self.couleur][b+1] == "Vide":
                    __Cases.append((a+self.couleur,b+1))
                if G[a][b-1].type == "Pion" and G[a][b-1].couleur == -self.couleur and G[a][b-1].imprudence and G[a+self.couleur][b-1] == "Vide":
                    __Cases.append((a+self.couleur,b-1))

        return __Cases
        
   
   def possibilites(self,a,b):
        _Cases_absolues = self.possibilitesAbsolues(a,b)
        _Cases_interdites = []
        for i in _Cases_absolues:
            (c,d) = i
            memo = G[c][d]
            G[c][d] = G[a][b]
            G[a][b] = Vide()
            if self.couleur == 1:
                if vulnerabilite(Ab,Bb,-1):
                    _Cases_interdites.append(i)
            if self.couleur == -1:
                if vulnerabilite(An,Bn,1):
                    _Cases_interdites.append(i)
            G[a][b] = G[c][d]
            G[c][d] = memo
        _Cases_autorisees = []
        for i in _Cases_absolues :
            if not i in _Cases_interdites :
                _Cases_autorisees.append(i)
        return _Cases_autorisees

#imprudence est un booléen activé lorsqu'un pion avance de 2, et immédiatement désactivé le coup suivant
 
class Cavalier():

    def __init__(self,couleur):
        self.couleur = couleur
        self.ligneInitiale = (-3.5*couleur + 3.5)
        self.type = "Cavalier"


    def possibilitesAbsolues(self,a,b):
        __Cases = []
        for c in range(a-2,a+3):
            for d in range(b-2,b+3):
                i = a-c
                j = b-d
                print(c,d)
                if i**2+j**2 == 5 and c < 8 and c > -1 and d < 8 and d > -1 and G[c][d].couleur != self.couleur :
                        __Cases += [(c,d)]
        print(__Cases)
        
    def possibilites(self,a,b):
        _Cases_absolues = self.possibilitesAbsolues(a,b)
        _Cases_interdites = []
        for i in _Cases_absolues:
            (c,d) = i
            memo = G[c][d]
            G[c][d] = G[a][b]
            G[a][b] = Vide()
            if self.couleur == 1:
                if vulnerabilite(Ab,Bb,-1):
                    _Cases_interdites.append(i)
            if self.couleur == -1:
                if vulnerabilite(An,Bn,1):
                    _Cases_interdites.append(i)
            G[a][b] = G[c][d]
            G[c][d] = memo
        _Cases_autorisees = []
        for i in _Cases_absolues :
            if not i in _Cases_interdites :
                _Cases_autorisees.append(i)
        return _Cases_autorisees


class Tour():
    def __init__(self,couleur):
        self.couleur=couleur
        self.ligneInitiale = (-3.5*couleur + 3.5)
        self.type = "Tour"
        self.virginite = True

    def possibilitesAbsolues(self,a,b):
        __Cases = []
        c = a+1
        while c < 8 and G[c][b].couleur != self.couleur:
            __Cases.append((c,b))
            if G[c][b].couleur == (-1)*self.couleur:
                c = 8
            c += 1
        c = a-1
        while c > -1 and G[c][b].couleur != self.couleur:
            __Cases.append((c,b))
            if G[c][b].couleur == (-1)*self.couleur:
                c = -1
            c -= 1
        d = b+1
        while d < 8 and G[a][d].couleur != self.couleur:
            __Cases.append((a,d))
            if G[a][d].couleur == (-1)*self.couleur:
                d = 8
            d += 1
        d = b-1
        while d > -1 and G[a][d].couleur != self.couleur:
            __Cases.append((a,d))
            if G[a][d].couleur == (-1)*self.couleur:
                d = -1
            d -= 1
        return __Cases
        
    def possibilites(self,a,b):
        _Cases_absolues = self.possibilitesAbsolues(a,b)
        _Cases_interdites = []
        for i in _Cases_absolues:
            (c,d) = i
            memo = G[c][d]
            G[c][d] = G[a][b]
            G[a][b] = Vide()
            if self.couleur == 1:
                if vulnerabilite(Ab,Bb,-1):
                    _Cases_interdites.append(i)
            if self.couleur == -1:
                if vulnerabilite(An,Bn,1):
                    _Cases_interdites.append(i)
            G[a][b] = G[c][d]
            G[c][d] = memo
        _Cases_autorisees = []
        for i in _Cases_absolues :
            if not i in _Cases_interdites :
                _Cases_autorisees.append(i)
        return _Cases_autorisees


class Fou():
    def __init__(self,couleur):
        self.couleur = couleur
        self.ligneInitiale = (-3.5*couleur + 3.5)
        self.type = "Fou"

    def possibilitesAbsolues(self,a,b):
        __Cases = []
        l = 1
        while a+l < 8 and b+l < 8 and G[a+l][b+l].couleur != self.couleur:
            __Cases.append((a+l,b+l))
            if G[a+l][b+l].couleur == (-1)*self.couleur:
                l = 8
            l += 1
        l = 1
        while a-l > -1 and b-l > -1 and G[a-l][b-l].couleur != self.couleur:
            __Cases.append((a-l,b-l))
            if G[a-l][b-l].couleur == (-1)*self.couleur:
                l = -1
            l += 1
        l = 1
        while a+l < 8 and b-l > -1 and G[a+l][b-l].couleur != self.couleur:
            __Cases.append((a+l,b-l))
            if G[a+l][b-l].couleur == (-1)*self.couleur:
                l = 8
            l += 1
        l = 1
        while a-l > -1 and b+l < 8 and G[a-l][b+l].couleur != self.couleur:
            __Cases.append((a-l,b+l))
            if G[a-l][b+l].couleur == (-1)*self.couleur:
                l = -1
            l += 1
        return __Cases
        
    def possibilites(self,a,b):
        _Cases_absolues = self.possibilitesAbsolues(a,b)
        _Cases_interdites = []
        for i in _Cases_absolues:
            (c,d) = i
            memo = G[c][d]
            G[c][d] = G[a][b]
            G[a][b] = Vide()
            if self.couleur == 1:
                if vulnerabilite(Ab,Bb,-1):
                    _Cases_interdites.append(i)
            if self.couleur == -1:
                if vulnerabilite(An,Bn,1):
                    _Cases_interdites.append(i)
            G[a][b] = G[c][d]
            G[c][d] = memo
        _Cases_autorisees = []
        for i in _Cases_absolues :
            if not i in _Cases_interdites :
                _Cases_autorisees.append(i)
        return _Cases_autorisees



class Dame():

    def __init__(self,couleur):
        self.couleur = couleur
        self.ligneInitiale = (-3.5*couleur + 3.5)
        self.type = "Dame"

    def possibilitesAbsolues(self,a,b):
        __Cases = []
        l = 1
        while a+l < 8 and b+l < 8 and G[a+l][b+l].couleur != self.couleur:
            __Cases.append((a+l,b+l))
            if G[a+l][b+l].couleur == (-1)*self.couleur:
                l = 8
            l += 1
        l = 1
        while a-l > -1 and b-l > -1 and G[a-l][b-l].couleur != self.couleur:
            __Cases.append((a-l,b-l))
            if G[a-l][b-l].couleur == (-1)*self.couleur:
                l = -1
            l += 1
        l = 1
        while a+l < 8 and b-l > -1 and G[a+l][b-l].couleur != self.couleur:
            __Cases.append((a+l,b-l))
            if G[a+l][b-l].couleur == (-1)*self.couleur:
                l = 8
            l += 1
        l = 1
        while a-l > -1 and b+l < 8 and G[a-l][b+l].couleur != self.couleur:
            __Cases.append((a-l,b+l))
            if G[a-l][b+l].couleur == (-1)*self.couleur:
                l = -1
            l += 1
        c = a+1
        while c < 8 and G[c][b].couleur != self.couleur:
            __Cases.append((c,b))
            if G[c][b].couleur == (-1)*self.couleur:
                c = 8
            c += 1
        c = a-1
        while c > -1 and G[c][b].couleur != self.couleur:
            __Cases.append((c,b))
            if G[c][b].couleur == (-1)*self.couleur:
                c = -1
            c -= 1
        d = b+1
        while d < 8 and G[a][d].couleur != self.couleur:
            __Cases.append((a,d))
            if G[a][d].couleur == (-1)*self.couleur:
                d = 8
            d += 1
        d = b-1
        while d > -1 and G[a][d].couleur != self.couleur:
            __Cases.append((a,d))
            if G[a][d].couleur == (-1)*self.couleur:
                d = -1
            d -= 1
        return __Cases

    def possibilites(self,a,b):
        _Cases_absolues = self.possibilitesAbsolues(a,b)
        _Cases_interdites = []
        for i in _Cases_absolues:
            (c,d) = i
            memo = G[c][d]
            G[c][d] = G[a][b]
            G[a][b] = Vide()
            if self.couleur == 1:
                if vulnerabilite(Ab,Bb,-1):
                    _Cases_interdites.append(i)
            if self.couleur == -1:
                if vulnerabilite(An,Bn,1):
                    _Cases_interdites.append(i)
            G[a][b] = G[c][d]
            G[c][d] = memo
        _Cases_autorisees = []
        for i in _Cases_absolues :
            if not i in _Cases_interdites :
                _Cases_autorisees.append(i)
        return _Cases_autorisees
        
        
class Roi():
    def __init__(self,couleur):
        self.couleur = couleur
        self.ligneInitiale = (-3.5*couleur + 3.5)
        self.type = "Roi"
        self.virginite = True

    def possibilitesAbsolues(self,a,b):
        __Cases = []
        for i in [-1, 0, 1]:
            for j in [-1, 0, 1]:
                c=a+i
                d=b+j
                if c<8 and d<8 and c>-1 and d>-1 and G[c][d].couleur!=self.couleur :
                    __Cases.append((c,d))
        return(__Cases)
        
    def roquabilite():
        r = [False,False]
        cou = self.couleur
        L = self.ligneInitiale 
        petitRoque = not(vulnerabilite(L,0,-cou) or vulnerabilite(L,1,-cou) or vulnerabilite(L,2,-cou) or vulnerabilite(L,3,-cou)) 
        grandRoque = not(vulnerabilite(L,3,-cou) or vulnerabilite(L,4,-cou) or vulnerabilite(L,5,-cou) or vulnerabilite(L,6,-cou) or vulnerabilite(L,7,-cou))
        if self.virginite:
            if  G[L][5] == "Vide" and G[L][6] == "Vide" and petitRoque and G[L][7].type == "Tour" and G[L][7].virginite :
                r[0] = True
            if G[L][3] == "Vide" and G[L][2] == "Vide" and G[L][1] == "Vide" and grandRoque and G[L][0].type == "Tour" and G[L][0].virginite:
                r[1] = True
        return(r)

    def possibilites(self,a,b):
        _Cases_absolues = self.possibilitesAbsolues(a,b)
        _Cases_interdites = []
        for i in _Cases_absolues:
            (c,d) = i
            memo = G[c][d]
            G[c][d] = G[a][b]
            G[a][b] = Vide()
            if vulnerabilite(c,d,-1*self.couleur):
                _Cases_interdites.append(i)
            G[a][b] = G[c][d]
            G[c][d] = memo
        _Cases_autorisees = []
        for i in _Cases_absolues :
            if not i in _Cases_interdites :
                _Cases_autorisees.append(i)
        return _Cases_autorisees

#roquabilite renvoie [True,True] si les deux roques sont possibles (donc si le joueur a sélectionné le roi), [True,Flase] si le petit roque est possible, [False,True] si le grand roque est possible.
   
           
           
#la fonction qui teste si la case (a,b) est dans la ligne de mire d'une pièce de couleur "coul"
def vulnerabilite(a,b,couleur):
    
    for c in range(8):
        for d in range(8):
            if G[c][d].couleur == couleur:
                if (a,b) in G[c][d].possibilitesAbsolues(c,d):
                    return True                
    return False                
                
#(Ab,Bb) position du roi blanc
#(An,Bn) position du roi noir
#(X,Y) case sur laquelle l'utilisateur clique au début de son tour
            
## Programme principal

G = []
for i in range(8):
    g = []
    for j in range(8):
        g += [0]
    G += [g]

G[0][0]=Tour(1)
G[0][7]=Tour(1)
G[7][0]=Tour(-1)
G[7][7]=Tour(-1)

G[0][1]=Cavalier(1)
G[0][6]=Cavalier(1)
G[7][1]=Cavalier(-1)
G[7][6]=Cavalier(-1)

G[0][2]=Fou(1)
G[0][5]=Fou(1)
G[7][2]=Fou(-1)
G[7][5]=Fou(-1)

G[0][3]=Roi(1)
G[0][4]=Dame(1)
G[7][3]=Roi(-1)
G[7][4]=Dame(-1)


for k in range (8):
    G[1][k]= Pion(1)
    G[6][k]= Pion(-1)

for i in range (8):
    for j in range(2, 6):
        G[i][j]=Vide()

J1=input("Joueur 1:")
J2=input("Joueur 2:")

H=input(str(J1)+", choisissez un côté ('pile' ou 'face'):")
while H!="face" and H!="pile":
    H=input("Vous devez saisir 'pile' ou 'face':")
Tirage=choice(["face", "pile"])
print("Le tirage donne", Tirage)
if Tirage==H:
    print(J1, "joue les blancs")
else:
    print(J2, "joue les blancs")
    
    
  ##Partie

#Si joueur est pair alors les pièces blanches peuvent être sélectionnées, sinon les pièces noires
joueur == 0

if clic = sélection_dune_pièce :
    X = abscisse_du_clic
    Y = ordonnée_du_clic

    
#nouveau est la dernière pièce à être jouée, dans son emplacement d'arivée

if clic = choix_dun_deplacement :
    
#réinitialisation des imprudences
    for i in range(0,7)
    for j in range(0,7)
        if G[i][j].type == "Pion": G[i][j].imprudence = False
        
#réinitialisation de la grille
    M = abscisse_darrivee
    N = ordonnee_darrivee
    G[M][N] = G[X][Y]
    G[X][Y] = Vide()
    nouveau = G[M][N]
    
#Progression des tours de jeux
    joueur += 1
    

#allumage de l'imprudence
    if nouveau.type = "Pion" and (X-M)**2 == 4 : nouveau.imprudence = True
#éteignage de la virginité
    if nouveau.type = "Tour" or nouveau.type = "Roi" : nouveau.virginite = False


    
## Remarques générales
# La situation pathologique où le roque serait un coup possible évitant le pat ET où la tour là où elle arrive après roque protège le roi d'un échec n'est pas un cas possible
# car il supposerait que le roi soit en échec avant le roque (puisque la tour protège horizontalement), ce qui est absurde. Ceci évite un problème avec la méthode pat.
    
    
## Roque, c'est rock'n roll croyez-moi
# Cas de la tour --> On ne sait pas si on garde le cas de la tour
# G[X][Y].type == "Tour":
#    if G[X][Y].type == "Tour" and G[X][Y].virginite and Y == 0 and G[L][3].type == "Roi" and G[L][3].virginite:
#        if  G[L][5] == "Vide" and G[L][6] == "Vide" and petitRoque and G[L][3].virginite:
#            roquabilite[0] = True
#    if G[X][Y].type == "Tour" and G[X][Y].virginite and Y == 7 and G[L][3].type == "Roi" and G[L][3].virginite:        
#        if G[L][3] == "Vide" and G[L][2] == "Vide" and G[L][1] == "Vide" and grandRoque:
#            roquabilite[1] = True



